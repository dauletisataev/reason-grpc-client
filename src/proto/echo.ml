(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: src/proto/echo.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocamlprotocplugin.Runtime [@@warning "-33"]
module Buhta = struct
  module rec Empty : sig
    val name': unit -> string
    type t = unit 
    val make : unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "echo.buhta.Empty"
    type t = unit
    let make =
      fun  () -> 
      
      ()
    
    let to_proto =
      let apply = fun ~f:f' () -> f' []  in
      let spec = Runtime'.Serialize.C.( nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions  -> () in
      let spec = Runtime'.Deserialize.C.( nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and EchoRequest : sig
    val name': unit -> string
    type t = string 
    val make : ?message:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "echo.buhta.EchoRequest"
    type t = string
    let make =
      fun ?message () -> 
      let message = match message with Some v -> v | None -> {||} in
      message
    
    let to_proto =
      let apply = fun ~f:f' message -> f' [] message in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions message -> message in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and EchoResponse : sig
    val name': unit -> string
    type t = string 
    val make : ?message:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "echo.buhta.EchoResponse"
    type t = string
    let make =
      fun ?message () -> 
      let message = match message with Some v -> v | None -> {||} in
      message
    
    let to_proto =
      let apply = fun ~f:f' message -> f' [] message in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions message -> message in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ServerStreamingEchoRequest : sig
    val name': unit -> string
    type t = { message: string; message_count: int; message_interval: int } 
    val make : ?message:string -> ?message_count:int -> ?message_interval:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "echo.buhta.ServerStreamingEchoRequest"
    type t = { message: string; message_count: int; message_interval: int }
    let make =
      fun ?message ?message_count ?message_interval () -> 
      let message = match message with Some v -> v | None -> {||} in
      let message_count = match message_count with Some v -> v | None -> 0 in
      let message_interval = match message_interval with Some v -> v | None -> 0 in
      { message; message_count; message_interval }
    
    let to_proto =
      let apply = fun ~f:f' { message; message_count; message_interval } -> f' [] message message_count message_interval in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, int32_int, proto3) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions message message_count message_interval -> { message; message_count; message_interval } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, int32_int, proto3) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ServerStreamingEchoResponse : sig
    val name': unit -> string
    type t = string 
    val make : ?message:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "echo.buhta.ServerStreamingEchoResponse"
    type t = string
    let make =
      fun ?message () -> 
      let message = match message with Some v -> v | None -> {||} in
      message
    
    let to_proto =
      let apply = fun ~f:f' message -> f' [] message in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions message -> message in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ClientStreamingEchoRequest : sig
    val name': unit -> string
    type t = string 
    val make : ?message:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "echo.buhta.ClientStreamingEchoRequest"
    type t = string
    let make =
      fun ?message () -> 
      let message = match message with Some v -> v | None -> {||} in
      message
    
    let to_proto =
      let apply = fun ~f:f' message -> f' [] message in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions message -> message in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ClientStreamingEchoResponse : sig
    val name': unit -> string
    type t = int 
    val make : ?message_count:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "echo.buhta.ClientStreamingEchoResponse"
    type t = int
    let make =
      fun ?message_count () -> 
      let message_count = match message_count with Some v -> v | None -> 0 in
      message_count
    
    let to_proto =
      let apply = fun ~f:f' message_count -> f' [] message_count in
      let spec = Runtime'.Serialize.C.( basic (1, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions message_count -> message_count in
      let spec = Runtime'.Deserialize.C.( basic (1, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  module EchoService = struct
    let echo = 
      ( (module EchoRequest : Runtime'.Service.Message with type t = EchoRequest.t ), 
      (module EchoResponse : Runtime'.Service.Message with type t = EchoResponse.t ) ) 
    let echoAbort = 
      ( (module EchoRequest : Runtime'.Service.Message with type t = EchoRequest.t ), 
      (module EchoResponse : Runtime'.Service.Message with type t = EchoResponse.t ) ) 
    let noOp = 
      ( (module Empty : Runtime'.Service.Message with type t = Empty.t ), 
      (module Empty : Runtime'.Service.Message with type t = Empty.t ) ) 
    let serverStreamingEcho = 
      ( (module ServerStreamingEchoRequest : Runtime'.Service.Message with type t = ServerStreamingEchoRequest.t ), 
      (module ServerStreamingEchoResponse : Runtime'.Service.Message with type t = ServerStreamingEchoResponse.t ) ) 
    let serverStreamingEchoAbort = 
      ( (module ServerStreamingEchoRequest : Runtime'.Service.Message with type t = ServerStreamingEchoRequest.t ), 
      (module ServerStreamingEchoResponse : Runtime'.Service.Message with type t = ServerStreamingEchoResponse.t ) ) 
    let clientStreamingEcho = 
      ( (module ClientStreamingEchoRequest : Runtime'.Service.Message with type t = ClientStreamingEchoRequest.t ), 
      (module ClientStreamingEchoResponse : Runtime'.Service.Message with type t = ClientStreamingEchoResponse.t ) ) 
    let fullDuplexEcho = 
      ( (module EchoRequest : Runtime'.Service.Message with type t = EchoRequest.t ), 
      (module EchoResponse : Runtime'.Service.Message with type t = EchoResponse.t ) ) 
    let halfDuplexEcho = 
      ( (module EchoRequest : Runtime'.Service.Message with type t = EchoRequest.t ), 
      (module EchoResponse : Runtime'.Service.Message with type t = EchoResponse.t ) ) 
  end
end